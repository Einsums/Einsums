//----------------------------------------------------------------------------------------------
// Copyright (c) The Einsums Developers. All rights reserved.
// Licensed under the MIT License. See LICENSE.txt in the project root for license information.
//----------------------------------------------------------------------------------------------

#pragma once

#include <Einsums/Errors/Error.hpp>
#include <Einsums/Errors/ThrowException.hpp>
#include <Einsums/GPUMemory/GPUPointer.hpp>
#include <Einsums/GPUMemory/InitModule.hpp>
#include <Einsums/GPUMemory/ModuleVars.hpp>
#include <Einsums/StringUtil/MemoryString.hpp>

#include <complex>
#include <hip/hip_common.h>
#include <hip/hip_complex.h>
#include <hip/hip_runtime.h>
#include <hip/hip_runtime_api.h>
#include <mutex>
#include <source_location>
#include <type_traits>

namespace einsums {

namespace gpu {

/**
 * @struct GPUAllocator
 *
 * @brief Allocator whose maximum size can be restricted by runtime variables and which allocates memory on a GPU.
 *
 * The maximum size is controlled by the global configuration options. In particular, the option to control the size is
 * @c --einsums:gpu-buffer-size and the string in the configuration mapping is @c gpu-buffer-size with the standard variants,
 * such as @c GPU_BUFFER_SIZE .
 *
 * Use in dynamic allocations with frequent resizing is discouraged, such as in a vector. Resizing requires the buffer
 * to be reallocated while still being allocated. If the buffers are big when resized, this means that the buffer
 * allocation will fail even though the result would be expected to fall within the range of acceptable sizes.
 * However, when using this to allocate a buffer once, this should be fine.
 *
 * This allocator follows the C++ standard for allocators, and can be used in templates that use them, such as
 * containers, smart pointers, and more.
 *
 * @tparam T The type that buffers created by this allocator contain.
 *
 * @versionadded{1.1.0}
 */
template <typename T>
struct GPUAllocator {
  public:
    /**
     * @typedef dev_datatype
     *
     * @brief The data type stored on the device. This is only different if T is complex.
     *
     * @versionadded{1.1.0}
     */
    using dev_datatype = std::conditional_t<
        std::is_same_v<std::remove_cv_t<T>, std::complex<float>>, hipFloatComplex,
        std::conditional_t<std::is_same_v<std::remove_cv_t<T>, std::complex<double>>, hipDoubleComplex, std::remove_cv_t<T>>>;

    /**
     * @typedef pointer
     *
     * @brief The pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using pointer = GPUPointer<T>;

    /**
     * @typedef const_pointer
     *
     * @brief The const pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using const_pointer = GPUPointer<T const>;

    /**
     * @typedef void_pointer
     *
     * @brief The void pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using void_pointer = GPUPointer<void>;

    /**
     * @typedef const_void_pointer
     *
     * @brief The const void pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using const_void_pointer = GPUPointer<void const>;

    /**
     * @typedef value_type
     *
     * @brief The data type stored by the pointers generated by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using value_type = dev_datatype;

    /**
     * @typedef size_type
     *
     * @brief The type used by size operations for this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using size_type = size_t;

    /**
     * @typedef difference_type
     *
     * @brief The type used for pointer offsets and pointer distances.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using difference_type = ptrdiff_t;

    /**
     * @brief Allocate a number of elements.
     *
     * @param[in] n The number of elements to allocate.
     *
     * @return A pointer to the allocated buffer.
     *
     * @throws std::runtime_error If there is not enough buffer memory to allocate the requested pointer.
     *
     * @versionadded{1.1.0}
     */
    pointer allocate(size_t n) {
        T *out;

        auto &vars = detail::Einsums_GPUMemory_vars::get_singleton();

        if (!vars.try_allocate(n * sizeof(T))) {
            EINSUMS_THROW_EXCEPTION(std::runtime_error, "Could not allocate enough memory on the GPU device. Requested {} bytes.",
                                    n * sizeof(T));
        }

        hip_catch(hipMalloc((void **)&out, n * sizeof(T)));

        return pointer(out);
    }

    /**
     * @brief Deallocate a number of elements.
     *
     * @param[in] p The pointer to deallocate.
     * @param[in] n The number of elements to deallocate.
     *
     * @versionadded{1.1.0}
     */
    void deallocate(pointer p, size_t n) {
        auto &vars = detail::Einsums_GPUMemory_vars::get_singleton();

        vars.deallocate(n * sizeof(T));

        hip_catch(hipFree((void *)p));
    }

    /**
     * @brief Construct a value at a pointer.
     *
     * This copies the data from the value to the requested location.
     *
     * @param[inout] xp The destination pointer.
     * @param[in] value The value to copy.
     *
     * @versionadded{1.1.0}
     */
    void construct(pointer xp, T const &value) {
        hip_catch(hipMemcpy((void *)xp, (void const *)&value, sizeof(value), hipMemcpyHostToDevice));
    }

    /**
     * @brief Does nothing, but is required by the allocator protocol.
     *
     * @param[in] xp The pointer to "destroy".
     *
     * @versionadded{1.1.0}
     */
    void destroy(pointer xp) {
        ; // Do nothing.
    }

    /**
     * @brief Get the maximum number of elements this allocator can allocate.
     *
     * This is controlled by options passed to Einsums.
     *
     * @return The maximum number of elements that can be allocated.
     *
     * @versionadded{1.1.0}
     */
    size_type max_size() const { return detail::Einsums_GPUMemory_vars::get_singleton().get_max_size() / sizeof(T); }
};

// template <typename T>
// struct MappedAllocator {
//   public:
//     /*
//      * @typedef dev_datatype
//      *
//      * @brief The data type stored on the device. This is only different if T is complex.
//      */
//     using dev_datatype = std::conditional_t<
//         std::is_same_v<std::remove_cv_t<T>, std::complex<float>>, hipFloatComplex,
//         std::conditional_t<std::is_same_v<std::remove_cv_t<T>, std::complex<double>>, hipDoubleComplex, std::remove_cv_t<T>>>;
//     using pointer            = T *;
//     using const_pointer      = T const *;
//     using void_pointer       = void *;
//     using const_void_pointer = void const *;
//     using value_type         = T;
//     using size_type          = size_t;
//     using difference_type    = ptrdiff_t;

//     pointer allocate(size_t n) {
//         pointer host_ptr = new T[n];

//         hip_catch(hipHostRegister(host_ptr, n * sizeof(T), hipHostRegisterDefault));

//         return host_ptr;
//     }

//     void deallocate(pointer p, size_t n) {
//         hip_catch(hipHostUnregister(static_cast<void *>(p)));
//         delete[] p;
//     }

//     template <typename... Args>
//     void construct(pointer xp, Args &&...args) {
//         *xp = T(std::forward<Args>(args)...);
//     }
// };

} // namespace gpu

} // namespace einsums