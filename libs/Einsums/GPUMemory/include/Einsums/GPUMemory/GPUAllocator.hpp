//----------------------------------------------------------------------------------------------
// Copyright (c) The Einsums Developers. All rights reserved.
// Licensed under the MIT License. See LICENSE.txt in the project root for license information.
//----------------------------------------------------------------------------------------------

#pragma once

#include <Einsums/Errors/Error.hpp>
#include <Einsums/Errors/ThrowException.hpp>
#include <Einsums/GPUMemory/GPUPointer.hpp>
#include <Einsums/GPUMemory/InitModule.hpp>
#include <Einsums/GPUMemory/ModuleVars.hpp>
#include <Einsums/GPUStreams/GPUStreams.hpp>
#include <Einsums/Logging.hpp>
#include <Einsums/StringUtil/MemoryString.hpp>

#include <complex>
#include <exception>
#include <hip/hip_common.h>
#include <hip/hip_complex.h>
#include <hip/hip_runtime.h>
#include <hip/hip_runtime_api.h>
#include <mutex>
#include <source_location>
#include <type_traits>

namespace einsums {

namespace gpu {

/**
 * @struct GPUAllocator
 *
 * @brief Allocator whose maximum size can be restricted by runtime variables and which allocates memory on a GPU.
 *
 * The maximum size is controlled by the global configuration options. In particular, the option to control the size is
 * @c --einsums:gpu-buffer-size and the string in the configuration mapping is @c gpu-buffer-size with the standard variants,
 * such as @c GPU_BUFFER_SIZE .
 *
 * Use in dynamic allocations with frequent resizing is discouraged, such as in a vector. Resizing requires the buffer
 * to be reallocated while still being allocated. If the buffers are big when resized, this means that the buffer
 * allocation will fail even though the result would be expected to fall within the range of acceptable sizes.
 * However, when using this to allocate a buffer once, this should be fine.
 *
 * This allocator follows the C++ standard for allocators, and can be used in templates that use them, such as
 * containers, smart pointers, and more.
 *
 * @tparam T The type that buffers created by this allocator contain.
 *
 * @versionadded{1.1.0}
 */
template <typename T>
struct GPUAllocator {
  public:
    /**
     * @typedef dev_datatype
     *
     * @brief The data type stored on the device. This is only different if T is complex.
     *
     * @versionadded{1.1.0}
     */
    using dev_datatype = std::conditional_t<
        std::is_same_v<std::remove_cv_t<T>, std::complex<float>>, hipFloatComplex,
        std::conditional_t<std::is_same_v<std::remove_cv_t<T>, std::complex<double>>, hipDoubleComplex, std::remove_cv_t<T>>>;

    /**
     * @typedef pointer
     *
     * @brief The pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using pointer = GPUPointer<T>;

    /**
     * @typedef const_pointer
     *
     * @brief The const pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using const_pointer = GPUPointer<T const>;

    /**
     * @typedef void_pointer
     *
     * @brief The void pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using void_pointer = GPUPointer<void>;

    /**
     * @typedef const_void_pointer
     *
     * @brief The const void pointer type returned by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using const_void_pointer = GPUPointer<void const>;

    /**
     * @typedef value_type
     *
     * @brief The data type stored by the pointers generated by this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using value_type = dev_datatype;

    /**
     * @typedef size_type
     *
     * @brief The type used by size operations for this allocator.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using size_type = size_t;

    /**
     * @typedef difference_type
     *
     * @brief The type used for pointer offsets and pointer distances.
     *
     * Required by the allocator protocol.
     *
     * @versionadded{1.1.0}
     */
    using difference_type = ptrdiff_t;

    /**
     * @property type_size
     *
     * The size of the types handled by this allocator. This is needed to handle void pointers, which traditionally
     * don't have a size, but should be treated as one byte.
     *
     * @versionadded{2.0.0}
     */
    constexpr static size_t type_size = sizeof(std::conditional_t<std::is_void_v<std::remove_cv_t<T>>, char, T>);

    /**
     * @brief Allocate a number of elements.
     *
     * @param[in] n The number of elements to allocate.
     *
     * @return A pointer to the allocated buffer.
     *
     * @throws std::runtime_error If there is not enough buffer memory to allocate the requested pointer.
     *
     * @versionadded{1.1.0}
     */
    pointer allocate(size_t n) {
        T *out;

        auto &vars = detail::Einsums_GPUMemory_vars::get_singleton();

        if (!vars.try_allocate(n * type_size)) {
            EINSUMS_THROW_EXCEPTION(std::runtime_error, "Could not allocate enough memory on the GPU device. Requested {} bytes.",
                                    n * type_size);
        }

        hip_catch(hipMalloc((void **)&out, n * type_size));

        return pointer(out);
    }

    /**
     * @brief Deallocate a number of elements.
     *
     * @param[in] p The pointer to deallocate.
     * @param[in] n The number of elements to deallocate.
     *
     * @versionadded{1.1.0}
     */
    void deallocate(pointer p, size_t n) {
        auto &vars = detail::Einsums_GPUMemory_vars::get_singleton();

        vars.deallocate(n * type_size);

        try {
            hip_catch(hipFree((void *)p));
        } catch (ErrorInvalidValue &e) {
            if (device_is_reset) {
                EINSUMS_LOG_DEBUG("Device has already been reset, and the pointer being deallocated was unrecognized.");
            } else {
                std::rethrow_exception(std::current_exception());
            }
        }
    }

    /**
     * @brief Construct a value at a pointer.
     *
     * This copies the data from the value to the requested location.
     *
     * @param[inout] xp The destination pointer.
     * @param[in] value The value to copy.
     *
     * @throws ErrorInvalidMemcpyDirection If the pointer provided is not a device pointer.
     *
     * @versionadded{1.1.0}
     */
    void construct(pointer xp, std::add_const_t<detail::reference_or_void_t<T>> value) {
        hip_catch(hipMemcpy((void *)xp, (void const *)&value, type_size, hipMemcpyHostToDevice));
    }

    /**
     * @brief Does nothing, but is required by the allocator protocol.
     *
     * @param[in] xp The pointer to "destroy".
     *
     * @versionadded{1.1.0}
     */
    void destroy(pointer xp) noexcept {
        ; // Do nothing.
    }

    /**
     * @brief Get the maximum number of elements this allocator can allocate.
     *
     * This is controlled by options passed to Einsums.
     *
     * @return The maximum number of elements that can be allocated.
     *
     * @versionadded{1.1.0}
     */
    size_type max_size() const { return detail::Einsums_GPUMemory_vars::get_singleton().get_max_size() / type_size; }

    /**
     * @brief Query the number of elements the allocator has free.
     *
     * This will return the number of elements that have not yet been allocated.
     *
     * @return The number of elements available to allocate.
     *
     * @versionadded{1.1.0}
     */
    [[nodiscard]] size_type available_size() const {

        try {
            return detail::Einsums_GPUMemory_vars::get_singleton().get_available() / type_size;

        } catch (std::runtime_error &) {
            return 0;
        }
    }
};

} // namespace gpu

} // namespace einsums